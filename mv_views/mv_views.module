<?php

/*
 * Implementation of hook_menu().
 */
function mv_views_menu() {
  $items = array();
  
  $items['admin/reports/mv_views'] = array(
    'title' => 'Views + MV integration',
    'page callback' => 'mv_views_page',
    'access callback' => TRUE,
  );
  
  return $items;
}

function mv_views_page() {
  $mviews = mv_views_materialized_view_info();
  return '<pre>' . check_plain(print_r($mviews, TRUE)) . '</pre>';
}

/*
 * Implementation of hook_materialized_view_info().
 */
function mv_views_materialized_view_info() {
  $mviews = array();

  $res = db_query('SELECT * FROM {views_display}');
  while ($views_display = db_fetch_object($res)) {
    $views_display->display_options = unserialize($views_display->display_options);
    $mview = mv_views_construct_mview($views_display);
    
    if ($mview !== FALSE) {
      $mviews[] = $mview;
    }
  }

  return $mviews;
}

function mv_views_construct_mview($views_display) {
  $mview = new MaterializedView('mv_' . $views_display->id);
  
  // Restrict to nodes
  $mview->addStaticFilter(new MVEntityType(), new MVEqualityOperator('node'));
  
  // Load filters, if any
  if (is_array($views_display->display_options['filters'])) {
    foreach ($views_display->display_options['filters'] as $name => $filter) {
      if ($filter['operator'] != '=' || $filter['exposed']) {
        dsm($views_display);
        return FALSE;
      }
      
      $value = $filter['value'];
      if (is_array($value)) {
        $value = $value['value'];
      }
      
      $mview->addStaticFilter(new MVViewsNodeColumn($filter['table'], $filter['field']), new MVEqualityOperator($value));
    }
  }
  
  // TODO: Load exposed filters as "dynamic" filters.
  
  // Does the View have a sort?
  if (is_array($views_display->display_options['sorts'])) {
    $sortset = new MVSortSet('mvv');
  
    foreach ($views_display->display_options['sorts'] as $sort) {
      $order = MV_SORT_ASCENDING;
      if ($sort['order'] == 'DESC') {
        $order = MV_SORT_DESCENDING;
      }
      
      $sortset->addSort(new MVViewsNodeColumn($sort['table'], $sort['field']), $order);
    }
  
    $mview->addSortSet($sortset);  
  }
  
  return $mview;
}

class MVViewsNodeColumn extends MVColumn {
  protected $table_name;
  protected $column_name;

  public function __construct($table_name, $column_name) {
    $this->table_name = $table_name;
    $this->column_name = $column_name;
  }

  public function getValue($entity_type, $entity_id) {
    $node = (array) MVEntityCache::get('node', $entity_id);
    
    if (isset($node[$this->column_name])) {
      return $node[$this->column_name];
    }
    
    // TODO: Probably stop assuming this is a CCK field.
    
    $values = array();
    $column = substr($this->column_name, 0, -6);
    if (is_array($node[$column])) {
      foreach ($node[$column] as $value) {
        $values[] = $value['value'];
      }
    }

    if (count($values) == 1) {
      return array_pop($values);
    }
    
    return $values;
  }

  // Perform a direct node-to-node change mapping.
  public function getChangeMapping($entity_type, $entity_id) {    
    $changed = array();
    if ($entity_type == 'node') {
      $changed[$entity_type] = array($entity_id);
    }
    return $changed;
  }

  public function getSchema() {
    $table = 'node';
    
    if ($this->table_name != 'node') {
      $views_path = drupal_get_path('module', 'views');
      require_once $views_path . '/includes/base.inc';
      require_once $views_path . '/includes/handlers.inc';
      $table = views_get_table_join($this->table_name, 'node');
      $table = $table->table;
    }
  
    $schema = drupal_get_schema($table);
    
    //$schema = drupal_get_schema_unprocessed('node', 'node');
    $field_schema = $schema['fields'][$this->column_name];

    // Override type "serial"
    if ($field_schema['type'] == 'serial') {
      $field_schema['type'] = 'int';
    }
    
    return $field_schema;
  }

  public function getName() {
    return $this->column_name;
  }
}
